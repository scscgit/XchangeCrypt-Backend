/*
 * TradingView REST API Specification for Brokers
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 *
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Runtime.Serialization;
using System.Text;

namespace IO.Swagger.Models
{
    /// <summary>
    /// SymbolInfo is an object containing symbols metadata. Each value of this object is an array of values which size is equal to symbols count or a single value that is applied to all symbols.
    /// </summary>
    [DataContract]
    public partial class SymbolInfoArrays : IEquatable<SymbolInfoArrays>
    {
        /// <summary>
        /// It&#39;s name of a symbol. It is a string which your users will see. Also, it will be used for data requests if you are not using tickers.
        /// </summary>
        /// <value>It&#39;s name of a symbol. It is a string which your users will see. Also, it will be used for data requests if you are not using tickers.</value>
        [Required]
        [DataMember(Name = "symbol")]
        public List<string> Symbol { get; set; }

        /// <summary>
        /// Description of a symbol. Will be printed in chart legend for this symbol.
        /// </summary>
        /// <value>Description of a symbol. Will be printed in chart legend for this symbol.</value>
        [Required]
        [DataMember(Name = "description")]
        public List<string> Description { get; set; }

        /// <summary>
        /// Short name of exchange where this symbol is listed
        /// </summary>
        /// <value>Short name of exchange where this symbol is listed</value>
        [Required]
        [DataMember(Name = "exchange-listed")]
        public List<string> ExchangeListed { get; set; }

        /// <summary>
        /// Short name of exchange where this symbol is traded
        /// </summary>
        /// <value>Short name of exchange where this symbol is traded</value>
        [Required]
        [DataMember(Name = "exchange-traded")]
        public List<string> ExchangeTraded { get; set; }

        /// <summary>
        /// Minimal integer price change
        /// </summary>
        /// <value>Minimal integer price change</value>
        [Required]
        [DataMember(Name = "minmovement")]
        public List<decimal?> Minmovement { get; set; }

        /// <summary>
        /// It&#39;s a number for complex price formatting cases
        /// </summary>
        /// <value>It&#39;s a number for complex price formatting cases</value>
        [DataMember(Name = "minmov2")]
        public List<decimal?> Minmov2 { get; set; }

        /// <summary>
        /// Boolean showing whether this symbol wants to have complex price formatting (see minmov2) or not
        /// </summary>
        /// <value>Boolean showing whether this symbol wants to have complex price formatting (see minmov2) or not</value>
        [DataMember(Name = "fractional")]
        public List<bool?> Fractional { get; set; }

        /// <summary>
        /// MinimalPossiblePriceChange &#x3D; minmovement / pricescale
        /// </summary>
        /// <value>MinimalPossiblePriceChange &#x3D; minmovement / pricescale</value>
        [Required]
        [DataMember(Name = "pricescale")]
        public List<decimal?> Pricescale { get; set; }

        /// <summary>
        /// Boolean showing whether symbol has intraday (minutes) history data. If it&#39;s false then all buttons for intradays resolutions will be disabled when this symbol is active in chart. If it is set to true, all resolutions that are supplied directly by the datafeed must be provided in intraday_multipliers array.
        /// </summary>
        /// <value>Boolean showing whether symbol has intraday (minutes) history data. If it&#39;s false then all buttons for intradays resolutions will be disabled when this symbol is active in chart. If it is set to true, all resolutions that are supplied directly by the datafeed must be provided in intraday_multipliers array.</value>
        [DataMember(Name = "has-intraday")]
        public List<bool?> HasIntraday { get; set; }

        /// <summary>
        /// Boolean showing whether symbol has volume data or not
        /// </summary>
        /// <value>Boolean showing whether symbol has volume data or not</value>
        [DataMember(Name = "has-no-volume")]
        public List<bool?> HasNoVolume { get; set; }

        /// <summary>
        /// Symbol type (forex/stock etc.)
        /// </summary>
        /// <value>Symbol type (forex/stock etc.)</value>
        [DataMember(Name = "type")]
        public List<string> Type { get; set; }

        /// <summary>
        /// It&#39;s an unique identifier for this symbol in your symbology. If you specify this property then its value will be used for all data requests for this symbol. ticker is treated to be equal to symbol if not specified explicitly.
        /// </summary>
        /// <value>It&#39;s an unique identifier for this symbol in your symbology. If you specify this property then its value will be used for all data requests for this symbol. ticker is treated to be equal to symbol if not specified explicitly.</value>
        [DataMember(Name = "ticker")]
        public List<string> Ticker { get; set; }

        /// <summary>
        /// Exchange timezone for this symbol. We expect to get name of time zone in olsondb format
        /// </summary>
        /// <value>Exchange timezone for this symbol. We expect to get name of time zone in olsondb format</value>
        [Required]
        [DataMember(Name = "timezone")]
        public List<string> Timezone { get; set; }

        /// <summary>
        /// Trading hours for this symbol. See the [Trading Sessions](https://github.com/tradingview/charting_library/wiki/Trading-Sessions) article to know more details.
        /// </summary>
        /// <value>Trading hours for this symbol. See the [Trading Sessions](https://github.com/tradingview/charting_library/wiki/Trading-Sessions) article to know more details.</value>
        [Required]
        [DataMember(Name = "session-regular")]
        public List<string> SessionRegular { get; set; }

        /// <summary>
        /// An array of resolutions which should be enabled in resolutions picker for this symbol. Each item of an array is expected to be a string.
        /// </summary>
        /// <value>An array of resolutions which should be enabled in resolutions picker for this symbol. Each item of an array is expected to be a string.</value>
        [DataMember(Name = "supported-resolutions")]
        public List<List<string>> SupportedResolutions { get; set; }

        /// <summary>
        /// The boolean value showing whether datafeed has its own D resolution bars or not. If has_daily &#x3D; false then Charting Library will build respective resolutions from intraday by itself. If not, then it will request those bars from datafeed.
        /// </summary>
        /// <value>The boolean value showing whether datafeed has its own D resolution bars or not. If has_daily &#x3D; false then Charting Library will build respective resolutions from intraday by itself. If not, then it will request those bars from datafeed.</value>
        [DataMember(Name = "has-daily")]
        public List<bool?> HasDaily { get; set; }

        /// <summary>
        /// It is an array containing intraday resolutions (in minutes) the datafeed wants to build by itself. E.g., if the datafeed reported he supports resolutions [\&quot;1\&quot;, \&quot;5\&quot;, \&quot;15\&quot;], but in fact it has only 1 minute bars for symbol X, it should set intraday_multipliers of X &#x3D; [1]. This will make Charting Library to build 5 and 15 resolutions by itself.
        /// </summary>
        /// <value>It is an array containing intraday resolutions (in minutes) the datafeed wants to build by itself. E.g., if the datafeed reported he supports resolutions [\&quot;1\&quot;, \&quot;5\&quot;, \&quot;15\&quot;], but in fact it has only 1 minute bars for symbol X, it should set intraday_multipliers of X &#x3D; [1]. This will make Charting Library to build 5 and 15 resolutions by itself.</value>
        [DataMember(Name = "intraday-multipliers")]
        public List<List<string>> IntradayMultipliers { get; set; }

        /// <summary>
        /// The boolean value showing whether datafeed has its own W and M resolution bars or not. If has_weekly_and_monthly &#x3D; false then Charting Library will build respective resolutions from D by itself. If not, then it will request those bars from datafeed.
        /// </summary>
        /// <value>The boolean value showing whether datafeed has its own W and M resolution bars or not. If has_weekly_and_monthly &#x3D; false then Charting Library will build respective resolutions from D by itself. If not, then it will request those bars from datafeed.</value>
        [DataMember(Name = "has-weekly-and-monthly")]
        public List<bool?> HasWeeklyAndMonthly { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class SymbolInfoArrays {\n");
            sb.Append("  Symbol: ").Append(Symbol).Append("\n");
            sb.Append("  Description: ").Append(Description).Append("\n");
            sb.Append("  ExchangeListed: ").Append(ExchangeListed).Append("\n");
            sb.Append("  ExchangeTraded: ").Append(ExchangeTraded).Append("\n");
            sb.Append("  Minmovement: ").Append(Minmovement).Append("\n");
            sb.Append("  Minmov2: ").Append(Minmov2).Append("\n");
            sb.Append("  Fractional: ").Append(Fractional).Append("\n");
            sb.Append("  Pricescale: ").Append(Pricescale).Append("\n");
            sb.Append("  HasIntraday: ").Append(HasIntraday).Append("\n");
            sb.Append("  HasNoVolume: ").Append(HasNoVolume).Append("\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("  Ticker: ").Append(Ticker).Append("\n");
            sb.Append("  Timezone: ").Append(Timezone).Append("\n");
            sb.Append("  SessionRegular: ").Append(SessionRegular).Append("\n");
            sb.Append("  SupportedResolutions: ").Append(SupportedResolutions).Append("\n");
            sb.Append("  HasDaily: ").Append(HasDaily).Append("\n");
            sb.Append("  IntradayMultipliers: ").Append(IntradayMultipliers).Append("\n");
            sb.Append("  HasWeeklyAndMonthly: ").Append(HasWeeklyAndMonthly).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == GetType() && Equals((SymbolInfoArrays) obj);
        }

        /// <summary>
        /// Returns true if SymbolInfoArrays instances are equal
        /// </summary>
        /// <param name="other">Instance of SymbolInfoArrays to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(SymbolInfoArrays other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;

            return
                (
                    Symbol == other.Symbol ||
                    Symbol != null &&
                    Symbol.SequenceEqual(other.Symbol)
                ) &&
                (
                    Description == other.Description ||
                    Description != null &&
                    Description.SequenceEqual(other.Description)
                ) &&
                (
                    ExchangeListed == other.ExchangeListed ||
                    ExchangeListed != null &&
                    ExchangeListed.SequenceEqual(other.ExchangeListed)
                ) &&
                (
                    ExchangeTraded == other.ExchangeTraded ||
                    ExchangeTraded != null &&
                    ExchangeTraded.SequenceEqual(other.ExchangeTraded)
                ) &&
                (
                    Minmovement == other.Minmovement ||
                    Minmovement != null &&
                    Minmovement.SequenceEqual(other.Minmovement)
                ) &&
                (
                    Minmov2 == other.Minmov2 ||
                    Minmov2 != null &&
                    Minmov2.SequenceEqual(other.Minmov2)
                ) &&
                (
                    Fractional == other.Fractional ||
                    Fractional != null &&
                    Fractional.SequenceEqual(other.Fractional)
                ) &&
                (
                    Pricescale == other.Pricescale ||
                    Pricescale != null &&
                    Pricescale.SequenceEqual(other.Pricescale)
                ) &&
                (
                    HasIntraday == other.HasIntraday ||
                    HasIntraday != null &&
                    HasIntraday.SequenceEqual(other.HasIntraday)
                ) &&
                (
                    HasNoVolume == other.HasNoVolume ||
                    HasNoVolume != null &&
                    HasNoVolume.SequenceEqual(other.HasNoVolume)
                ) &&
                (
                    Type == other.Type ||
                    Type != null &&
                    Type.SequenceEqual(other.Type)
                ) &&
                (
                    Ticker == other.Ticker ||
                    Ticker != null &&
                    Ticker.SequenceEqual(other.Ticker)
                ) &&
                (
                    Timezone == other.Timezone ||
                    Timezone != null &&
                    Timezone.SequenceEqual(other.Timezone)
                ) &&
                (
                    SessionRegular == other.SessionRegular ||
                    SessionRegular != null &&
                    SessionRegular.SequenceEqual(other.SessionRegular)
                ) &&
                (
                    SupportedResolutions == other.SupportedResolutions ||
                    SupportedResolutions != null &&
                    SupportedResolutions.SequenceEqual(other.SupportedResolutions)
                ) &&
                (
                    HasDaily == other.HasDaily ||
                    HasDaily != null &&
                    HasDaily.SequenceEqual(other.HasDaily)
                ) &&
                (
                    IntradayMultipliers == other.IntradayMultipliers ||
                    IntradayMultipliers != null &&
                    IntradayMultipliers.SequenceEqual(other.IntradayMultipliers)
                ) &&
                (
                    HasWeeklyAndMonthly == other.HasWeeklyAndMonthly ||
                    HasWeeklyAndMonthly != null &&
                    HasWeeklyAndMonthly.SequenceEqual(other.HasWeeklyAndMonthly)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                var hashCode = 41;
                // Suitable nullity checks etc, of course :)
                if (Symbol != null)
                    hashCode = hashCode * 59 + Symbol.GetHashCode();
                if (Description != null)
                    hashCode = hashCode * 59 + Description.GetHashCode();
                if (ExchangeListed != null)
                    hashCode = hashCode * 59 + ExchangeListed.GetHashCode();
                if (ExchangeTraded != null)
                    hashCode = hashCode * 59 + ExchangeTraded.GetHashCode();
                if (Minmovement != null)
                    hashCode = hashCode * 59 + Minmovement.GetHashCode();
                if (Minmov2 != null)
                    hashCode = hashCode * 59 + Minmov2.GetHashCode();
                if (Fractional != null)
                    hashCode = hashCode * 59 + Fractional.GetHashCode();
                if (Pricescale != null)
                    hashCode = hashCode * 59 + Pricescale.GetHashCode();
                if (HasIntraday != null)
                    hashCode = hashCode * 59 + HasIntraday.GetHashCode();
                if (HasNoVolume != null)
                    hashCode = hashCode * 59 + HasNoVolume.GetHashCode();
                if (Type != null)
                    hashCode = hashCode * 59 + Type.GetHashCode();
                if (Ticker != null)
                    hashCode = hashCode * 59 + Ticker.GetHashCode();
                if (Timezone != null)
                    hashCode = hashCode * 59 + Timezone.GetHashCode();
                if (SessionRegular != null)
                    hashCode = hashCode * 59 + SessionRegular.GetHashCode();
                if (SupportedResolutions != null)
                    hashCode = hashCode * 59 + SupportedResolutions.GetHashCode();
                if (HasDaily != null)
                    hashCode = hashCode * 59 + HasDaily.GetHashCode();
                if (IntradayMultipliers != null)
                    hashCode = hashCode * 59 + IntradayMultipliers.GetHashCode();
                if (HasWeeklyAndMonthly != null)
                    hashCode = hashCode * 59 + HasWeeklyAndMonthly.GetHashCode();
                return hashCode;
            }
        }

        #region Operators

#pragma warning disable 1591

        public static bool operator ==(SymbolInfoArrays left, SymbolInfoArrays right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(SymbolInfoArrays left, SymbolInfoArrays right)
        {
            return !Equals(left, right);
        }

#pragma warning restore 1591

        #endregion Operators
    }
}
